"""Code-based state transition - ported from Qontinui framework.

Transition implementation defined in Python code (as opposed to DSL/JSON configuration).
"""

from typing import Set, Optional, Callable, List
from dataclasses import dataclass, field

from ...model.transition.state_transition import StateTransition, StaysVisible


@dataclass
class CodeStateTransition(StateTransition):
    """Code-based state transition implementation.
    
    Python implementation of code-based state transitions (originally JavaStateTransition in Brobot).
    
    CodeStateTransition represents transitions defined through Python code using callable 
    functions. This implementation enables dynamic, programmatic state navigation where transition 
    logic can involve complex conditions, external data, or runtime calculations that cannot be 
    expressed declaratively in DSL/JSON configuration.
    
    Key components:
    - Transition Function: Callable that executes the transition logic
    - Activation List: States to activate after successful transition
    - Exit List: States to deactivate after successful transition
    - Visibility Control: Whether source state remains visible post-transition
    - Path Score: Weight for path-finding algorithms (higher = less preferred)
    
    State reference handling:
    - Uses state names during definition (IDs not yet assigned)
    - Names are converted to IDs during initialization
    - Both name and ID sets are maintained for flexibility
    - Supports multiple target states for branching transitions
    
    Transition execution flow:
    1. Callable is invoked to perform transition logic
    2. If True is returned, transition is considered successful
    3. States in 'activate' set become active
    4. States in 'exit' set become inactive
    5. Success counter is incremented for metrics
    
    Common use patterns:
    - Complex navigation logic that depends on runtime conditions
    - Transitions involving external API calls or data validation
    - Dynamic state activation based on application state
    - Fallback transitions with custom error handling
    
    In the model-based approach, CodeStateTransition provides the flexibility needed for 
    complex automation scenarios where declarative configuration transitions are insufficient. It 
    bridges the gap between high-level state modeling and low-level action execution, enabling 
    sophisticated navigation strategies.
    
    This contrasts with DSL-based transitions that are created from JSON configuration
    files generated by the Qontinui configuration website.
    """
    
    # State management
    activate: Set[int] = field(default_factory=set)
    """State IDs to activate after successful transition."""
    
    activate_names: Set[str] = field(default_factory=set)
    """State names to activate (converted to IDs during initialization)."""
    
    exit: Set[int] = field(default_factory=set)
    """State IDs to deactivate after successful transition."""
    
    exit_names: Set[str] = field(default_factory=set)
    """State names to deactivate (converted to IDs during initialization)."""
    
    # Transition logic
    transition_function: Optional[Callable[[], bool]] = None
    """Python callable that implements the transition logic."""
    
    # Post-transition state
    stays_visible_after_transition: StaysVisible = StaysVisible.NONE
    """Controls whether source state remains visible after transition."""
    
    # Path-finding
    score: int = 100
    """Path-finding weight for this transition (lower is better)."""
    
    # Metrics
    times_successful: int = 0
    """Counter for successful transition executions."""
    
    def execute(self) -> bool:
        """Execute the transition function.
        
        Returns:
            True if transition succeeded, False otherwise
        """
        if self.transition_function is None:
            return False
        
        try:
            success = self.transition_function()
            if success:
                self.times_successful += 1
            return success
        except Exception as e:
            # Log error but don't crash
            import logging
            logging.error(f"Transition function failed: {e}")
            return False
    
    def get_activated_states(self) -> Set[int]:
        """Get state IDs that will be activated.
        
        Returns:
            Set of state IDs to activate
        """
        return self.activate.copy()
    
    def get_deactivated_states(self) -> Set[int]:
        """Get state IDs that will be deactivated.
        
        Returns:
            Set of state IDs to deactivate
        """
        return self.exit.copy()
    
    def set_state_ids(self, name_to_id: dict) -> None:
        """Convert state names to IDs.
        
        Args:
            name_to_id: Mapping of state names to IDs
        """
        # Convert activate names to IDs
        for name in self.activate_names:
            if name in name_to_id:
                self.activate.add(name_to_id[name])
        
        # Convert exit names to IDs
        for name in self.exit_names:
            if name in name_to_id:
                self.exit.add(name_to_id[name])
    
    # Abstract method implementations from StateTransition
    
    def get_task_sequence_optional(self) -> Optional:
        """Get task sequence (None for code-based transitions).
        
        Returns:
            None - code transitions don't use task sequences
        """
        return None
    
    def get_stays_visible_after_transition(self) -> StaysVisible:
        """Get visibility behavior after transition.
        
        Returns:
            StaysVisible enum value
        """
        return self.stays_visible_after_transition
    
    def set_stays_visible_after_transition(self, stays_visible: StaysVisible) -> None:
        """Set visibility behavior after transition.
        
        Args:
            stays_visible: StaysVisible enum value
        """
        self.stays_visible_after_transition = stays_visible
    
    def get_activate(self) -> Set[int]:
        """Get state IDs to activate.
        
        Returns:
            Set of state IDs
        """
        return self.activate
    
    def set_activate(self, activate: Set[int]) -> None:
        """Set state IDs to activate.
        
        Args:
            activate: Set of state IDs
        """
        self.activate = activate
    
    def get_exit(self) -> Set[int]:
        """Get state IDs to exit.
        
        Returns:
            Set of state IDs
        """
        return self.exit
    
    def set_exit(self, exit: Set[int]) -> None:
        """Set state IDs to exit.
        
        Args:
            exit: Set of state IDs
        """
        self.exit = exit
    
    def get_score(self) -> int:
        """Get path-finding score.
        
        Returns:
            Score value
        """
        return self.score
    
    def set_score(self, score: int) -> None:
        """Set path-finding score.
        
        Args:
            score: Score value
        """
        self.score = score
    
    def get_times_successful(self) -> int:
        """Get success count.
        
        Returns:
            Number of successful executions
        """
        return self.times_successful
    
    def set_times_successful(self, times_successful: int) -> None:
        """Set success count.
        
        Args:
            times_successful: Number of successful executions
        """
        self.times_successful = times_successful
    
    def __str__(self) -> str:
        """String representation."""
        activated = ', '.join(self.activate_names) if self.activate_names else 'None'
        exited = ', '.join(self.exit_names) if self.exit_names else 'None'
        return f"CodeTransition(activate=[{activated}], exit=[{exited}], score={self.score})"